<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SIR Epidemic Model Simulation - Hexperiment Labs</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        .header h1 {
            color: #2c3e50;
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header .subtitle {
            color: #7f8c8d;
            font-size: 1.2em;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .control-panel {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        .visualization-panel {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        .panel-title {
            font-size: 1.4em;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 20px;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }

        .parameter-group {
            margin-bottom: 25px;
        }

        .parameter-group h3 {
            color: #34495e;
            margin-bottom: 15px;
            font-size: 1.1em;
        }

        .parameter-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .parameter-label {
            color: #555;
            font-weight: 500;
            flex: 1;
        }

        .parameter-input {
            width: 100px;
            padding: 8px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        .parameter-input:focus {
            outline: none;
            border-color: #3498db;
        }

        .parameter-range {
            width: 150px;
            margin-left: 10px;
        }

        .scenario-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 20px;
        }

        .scenario-btn {
            padding: 12px;
            border: none;
            border-radius: 8px;
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .scenario-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
        }

        .scenario-btn.active {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
        }

        .control-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .control-btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .start-btn {
            background: linear-gradient(135deg, #27ae60, #2ecc71);
            color: white;
        }

        .stop-btn {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
        }

        .reset-btn {
            background: linear-gradient(135deg, #f39c12, #e67e22);
            color: white;
        }

        .control-btn:hover {
            transform: translateY(-2px);
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .metric-card {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .metric-value {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .metric-label {
            color: #7f8c8d;
            font-size: 0.9em;
        }

        .susceptible { color: #3498db; }
        .infected { color: #e74c3c; }
        .recovered { color: #27ae60; }
        .exposed { color: #f39c12; }

        .chart-container {
            height: 400px;
            margin-bottom: 20px;
        }

        .status-display {
            background: rgba(52, 152, 219, 0.1);
            border-left: 4px solid #3498db;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 5px;
        }

        .status-display h4 {
            color: #2c3e50;
            margin-bottom: 5px;
        }        .visualization-3d {
            height: 300px;
            background: #f8f9fa;
            border-radius: 10px;
            margin-top: 20px;
            position: relative;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #7f8c8d;
        }        @media (max-width: 768px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
            
            .scenario-buttons {
                grid-template-columns: 1fr;
            }
        }
        
        /* Added classes to replace inline styles */
        .hidden {
            display: none;
        }
        
        .status-indicators-container {
            margin-top: 10px;
        }
        
        .status-indicators-flex {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .status-indicator-style {
            font-size: 0.9em;
            padding: 5px 10px;
            border-radius: 15px;
            background: #f8f9fa;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ðŸ¦  SIR Epidemic Model Simulation</h1>
            <p class="subtitle">Comprehensive Epidemic Modeling & Visualization System</p>
        </div>

        <div class="main-grid">
            <!-- Control Panel -->
            <div class="control-panel">
                <h2 class="panel-title">Simulation Controls</h2>
                
                <div class="scenario-buttons">
                    <button class="scenario-btn active" onclick="setScenario('sir')">Basic SIR</button>
                    <button class="scenario-btn" onclick="setScenario('seir')">SEIR Model</button>
                    <button class="scenario-btn" onclick="setScenario('vaccination')">Vaccination</button>
                    <button class="scenario-btn" onclick="setScenario('variants')">Variants</button>
                </div>

                <div class="parameter-group">
                    <h3>Population Parameters</h3>                    <div class="parameter-row">
                        <label for="population" class="parameter-label">Total Population:</label>
                        <input type="number" id="population" class="parameter-input" value="100000" min="1000" max="10000000">
                    </div>
                    <div class="parameter-row">
                        <label for="initialInfected" class="parameter-label">Initial Infected:</label>
                        <input type="number" id="initialInfected" class="parameter-input" value="10" min="1" max="1000">
                    </div>
                </div>

                <div class="parameter-group">
                    <h3>Disease Parameters</h3>                    <div class="parameter-row">
                        <label for="beta" class="parameter-label">Transmission Rate (Î²):</label>
                        <input type="number" id="beta" class="parameter-input" value="0.3" step="0.01" min="0" max="2">
                        <input type="range" id="betaRange" class="parameter-range" value="30" min="0" max="200" aria-label="Transmission Rate slider">
                    </div>
                    <div class="parameter-row">
                        <label for="gamma" class="parameter-label">Recovery Rate (Î³):</label>
                        <input type="number" id="gamma" class="parameter-input" value="0.1" step="0.01" min="0" max="1">
                        <input type="range" id="gammaRange" class="parameter-range" value="10" min="0" max="100" aria-label="Recovery Rate slider">
                    </div>                    <div id="sigmaRow" class="parameter-row hidden">
                        <label for="sigma" class="parameter-label">Incubation Rate (Ïƒ):</label>
                        <input type="number" id="sigma" class="parameter-input" value="0.2" step="0.01" min="0" max="1">
                        <input type="range" id="sigmaRange" class="parameter-range" value="20" min="0" max="100" aria-label="Incubation Rate slider">
                    </div>
                </div>                <div id="vaccinationGroup" class="parameter-group hidden">
                    <h3>Vaccination Parameters</h3>
                    <div class="parameter-row">
                        <label for="vaccinationRate" class="parameter-label">Vaccination Rate:</label>
                        <input type="number" id="vaccinationRate" class="parameter-input" value="0.01" step="0.001" min="0" max="0.1">
                    </div>
                    <div class="parameter-row">
                        <label for="vaccineEfficacy" class="parameter-label">Vaccine Efficacy:</label>
                        <input type="number" id="vaccineEfficacy" class="parameter-input" value="0.95" step="0.01" min="0" max="1">
                    </div>
                </div>

                <div class="parameter-group">
                    <h3>Simulation Settings</h3>                    <div class="parameter-row">
                        <label for="timeSteps" class="parameter-label">Time Steps:</label>
                        <input type="number" id="timeSteps" class="parameter-input" value="365" min="30" max="1000">
                    </div>
                    <div class="parameter-row">
                        <label for="updateInterval" class="parameter-label">Update Interval (ms):</label>
                        <input type="number" id="updateInterval" class="parameter-input" value="50" min="10" max="1000">
                    </div>
                </div>                <div class="control-buttons">
                    <button class="control-btn start-btn" onclick="startSimulation()">Start</button>
                    <button class="control-btn stop-btn" onclick="stopSimulation()">Stop</button>
                    <button class="control-btn reset-btn" onclick="resetSimulation()">Reset</button>
                </div>

                <!-- Distributed Simulation Controls -->
                <div class="parameter-group">
                    <h3>Distributed Simulation</h3>
                    <div class="control-buttons">
                        <button class="control-btn start-btn" onclick="saveCurrentSimulation()">Save to API</button>
                        <button class="control-btn" onclick="loadSimulationFromAPI()">Load from API</button>
                        <button class="control-btn start-btn" onclick="runDistributedSim()">Run Distributed</button>
                    </div>                    <div class="status-indicators status-indicators-container">
                        <div class="status-indicators-flex">
                            <span id="apiStatus" class="status-indicator status-indicator-style">API: Checking...</span>
                            <span id="agentsStatus" class="status-indicator status-indicator-style">Agents: Checking...</span>
                            <span id="wsStatus" class="status-indicator status-indicator-style">WebSocket: Disconnected</span>
                        </div>
                    </div>
                </div>

                <div class="status-display">
                    <h4>Simulation Status</h4>
                    <p id="simulationStatus">Ready to start</p>
                    <p id="currentDay">Day: 0</p>
                    <p id="reproductionNumber">Râ‚€: <span id="r0Value">3.0</span></p>
                </div>

                <div id="connectionStatus" class="connection-status"></div>
            </div>

            <!-- Visualization Panel -->
            <div class="visualization-panel">
                <h2 class="panel-title">Real-time Visualization</h2>
                <div class="chart-container" id="mainChart"></div>
                
                <div class="metrics-grid">                    <div class="metric-card">
                        <div class="metric-value susceptible" id="susceptibleCount">99,990</div>
                        <div class="metric-label">Susceptible</div>
                    </div>
                    <div class="metric-card hidden" id="exposedCard">
                        <div class="metric-value exposed" id="exposedCount">0</div>
                        <div class="metric-label">Exposed</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value infected" id="infectedCount">10</div>
                        <div class="metric-label">Infected</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value recovered" id="recoveredCount">0</div>
                        <div class="metric-label">Recovered</div>
                    </div>
                </div>                <div class="visualization-3d" id="3dContainer">
                    <div class="loading">3D Population Dynamics (Coming Soon)</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // API Integration Configuration
        const API_BASE_URL = 'http://localhost:3001/api';
        const AGENTS_BASE_URL = 'http://localhost:3002/api';
        const WS_URL = 'ws://localhost:3003';
        
        // WebSocket connection for real-time agent communication
        let agentSocket = null;
        let currentSimulationId = null;
        
        // Initialize WebSocket connection
        function initializeAgentConnection() {
            try {
                agentSocket = new WebSocket(WS_URL);
                  agentSocket.onopen = function(event) {
                    console.log('Connected to Babillon Agents');
                    updateConnectionStatus('Connected to Agents Service', 'success');
                    updateStatusIndicator('wsStatus', 'Connected âœ“', 'success');
                };
                
                agentSocket.onmessage = function(event) {
                    const data = JSON.parse(event.data);
                    handleAgentMessage(data);
                };
                  agentSocket.onclose = function(event) {
                    console.log('Disconnected from Babillon Agents');
                    updateConnectionStatus('Disconnected from Agents Service', 'warning');
                    updateStatusIndicator('wsStatus', 'Disconnected âœ—', 'error');
                    // Attempt to reconnect after 5 seconds
                    setTimeout(initializeAgentConnection, 5000);
                };
                  agentSocket.onerror = function(error) {
                    console.error('WebSocket error:', error);
                    updateConnectionStatus('Agent Connection Error', 'error');
                    updateStatusIndicator('wsStatus', 'Error âš ', 'error');
                };
            } catch (error) {
                console.error('Failed to connect to agents:', error);
                updateConnectionStatus('Failed to connect to Agents Service', 'error');
            }
        }
        
        // Handle messages from agents
        function handleAgentMessage(data) {
            switch (data.type) {
                case 'connected':
                    console.log('Agent connected:', data.agentId);
                    updateConnectionStatus(`Agent ${data.agentId.substr(0, 8)} connected`, 'success');
                    break;
                    
                case 'simulation_complete':
                    console.log('Simulation completed by agent:', data.simulationId);
                    handleDistributedSimulationResult(data.results);
                    break;
                    
                case 'simulation_error':
                    console.error('Agent simulation error:', data.error);
                    updateConnectionStatus(`Simulation Error: ${data.error}`, 'error');
                    break;
                    
                case 'pong':
                    // Keep-alive response
                    break;
                    
                default:
                    console.log('Unknown agent message:', data);
            }
        }
        
        // Update connection status display
        function updateConnectionStatus(message, type) {
            const statusElement = document.getElementById('connectionStatus');
            if (statusElement) {
                statusElement.textContent = message;
                statusElement.className = `connection-status ${type}`;
            }
        }
        
        // Save simulation to API
        async function saveSimulation(parameters, scenario, results) {
            try {
                const response = await fetch(`${API_BASE_URL}/simulations/sir`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        parameters,
                        scenario,
                        duration: parseInt(document.getElementById('timeSteps').value),
                        results
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    currentSimulationId = data.simulationId;
                    console.log('Simulation saved:', data.simulationId);
                    updateConnectionStatus(`Simulation saved: ${data.simulationId}`, 'success');
                    return data;
                } else {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
            } catch (error) {
                console.error('Failed to save simulation:', error);
                updateConnectionStatus('Failed to save simulation', 'error');
                return null;
            }
        }
        
        // Run distributed simulation via agents
        function runDistributedSimulation(parameters, scenario) {
            if (agentSocket && agentSocket.readyState === WebSocket.OPEN) {
                const message = {
                    type: 'sir_simulation',
                    data: {
                        parameters,
                        scenario,
                        duration: parseInt(document.getElementById('timeSteps').value)
                    }
                };
                
                agentSocket.send(JSON.stringify(message));
                updateConnectionStatus('Distributed simulation started', 'info');
                console.log('Sent simulation request to agents');
                return true;
            } else {
                console.warn('No agent connection available, running local simulation');
                updateConnectionStatus('No agent connection, running locally', 'warning');
                return false;
            }
        }
        
        // Handle distributed simulation results
        function handleDistributedSimulationResult(results) {
            if (results && results.time && results.susceptible && results.infected && results.recovered) {
                console.log('Received distributed simulation results');
                updateConnectionStatus('Distributed simulation completed', 'success');
                
                // Update the plot with distributed results
                updatePlot(results.time, results.susceptible, results.infected, results.recovered);
                
                // Update metrics
                const currentStep = results.time.length - 1;
                if (currentStep >= 0) {
                    updateMetrics(
                        results.susceptible[currentStep],
                        results.infected[currentStep],
                        results.recovered[currentStep],
                        0 // No exposed compartment in basic SIR
                    );
                }
                
                // Save the distributed results
                const parameters = getCurrentParameters();
                const scenario = currentScenario;
                saveSimulation(parameters, scenario, results);
            }
        }
        
        // Get current simulation parameters
        function getCurrentParameters() {
            return {
                beta: parseFloat(document.getElementById('beta').value),
                gamma: parseFloat(document.getElementById('gamma').value),
                sigma: parseFloat(document.getElementById('sigma').value),
                population: parseInt(document.getElementById('population').value),
                initialInfected: parseInt(document.getElementById('initialInfected').value),
                vaccinationRate: parseFloat(document.getElementById('vaccinationRate').value),
                vaccineEfficacy: parseFloat(document.getElementById('vaccineEfficacy').value)
            };
        }
        
        // Check API and Agents service health
        async function checkServiceHealth() {
            try {
                const [apiHealth, agentsHealth] = await Promise.all([
                    fetch(`${API_BASE_URL}/health`).then(r => r.json()).catch(() => null),
                    fetch(`${AGENTS_BASE_URL}/health`).then(r => r.json()).catch(() => null)
                ]);
                
                let statusMessage = 'Services: ';
                if (apiHealth && apiHealth.status === 'ok') {
                    statusMessage += 'API âœ“ ';
                } else {
                    statusMessage += 'API âœ— ';
                }
                
                if (agentsHealth && agentsHealth.status === 'ok') {
                    statusMessage += 'Agents âœ“';
                } else {
                    statusMessage += 'Agents âœ—';
                }
                
                updateConnectionStatus(statusMessage, apiHealth && agentsHealth ? 'success' : 'warning');
                
                return { api: !!apiHealth, agents: !!agentsHealth };
            } catch (error) {
                updateConnectionStatus('Service health check failed', 'error');
                return { api: false, agents: false };
            }
        }

        // SIR Model Simulation Engine
        class SIRSimulation {
            constructor() {
                this.isRunning = false;
                this.currentDay = 0;
                this.data = {
                    time: [],
                    susceptible: [],
                    exposed: [],
                    infected: [],
                    recovered: [],
                    vaccinated: []
                };
                this.scenario = 'sir';
                this.intervalId = null;
                this.initializeParameters();
                this.initializePlot();
                this.setupParameterBindings();
            }

            initializeParameters() {
                this.params = {
                    population: 100000,
                    initialInfected: 10,
                    beta: 0.3,
                    gamma: 0.1,
                    sigma: 0.2,
                    vaccinationRate: 0.01,
                    vaccineEfficacy: 0.95,
                    timeSteps: 365,
                    updateInterval: 50
                };
                
                this.state = {
                    S: this.params.population - this.params.initialInfected,
                    E: 0,
                    I: this.params.initialInfected,
                    R: 0,
                    V: 0
                };
            }

            setupParameterBindings() {
                // Bind input fields to parameters
                const inputs = ['population', 'initialInfected', 'beta', 'gamma', 'sigma', 
                               'vaccinationRate', 'vaccineEfficacy', 'timeSteps', 'updateInterval'];
                
                inputs.forEach(param => {
                    const input = document.getElementById(param);
                    const range = document.getElementById(param + 'Range');
                    
                    if (input) {
                        input.addEventListener('input', () => {
                            this.params[param] = parseFloat(input.value);
                            if (range) {
                                range.value = input.value * (param === 'beta' ? 100 : param === 'gamma' || param === 'sigma' ? 100 : 1);
                            }
                            this.updateR0();
                        });
                    }
                    
                    if (range) {
                        range.addEventListener('input', () => {
                            const value = parseFloat(range.value) / (param === 'beta' ? 100 : param === 'gamma' || param === 'sigma' ? 100 : 1);
                            this.params[param] = value;
                            input.value = value;
                            this.updateR0();
                        });
                    }
                });
            }

            updateR0() {
                const r0 = this.params.beta / this.params.gamma;
                document.getElementById('r0Value').textContent = r0.toFixed(2);
            }

            setScenario(scenario) {
                this.scenario = scenario;
                
                // Update UI based on scenario
                document.querySelectorAll('.scenario-btn').forEach(btn => btn.classList.remove('active'));
                event.target.classList.add('active');
                
                const sigmaRow = document.getElementById('sigmaRow');
                const vaccinationGroup = document.getElementById('vaccinationGroup');
                const exposedCard = document.getElementById('exposedCard');
                  switch(scenario) {
                    case 'sir':
                        sigmaRow.classList.add('hidden');
                        vaccinationGroup.classList.add('hidden');
                        exposedCard.classList.add('hidden');
                        break;
                    case 'seir':
                        sigmaRow.classList.remove('hidden');
                        vaccinationGroup.classList.add('hidden');
                        exposedCard.classList.remove('hidden');
                        break;
                    case 'vaccination':
                        sigmaRow.classList.add('hidden');
                        vaccinationGroup.classList.remove('hidden');
                        exposedCard.classList.add('hidden');
                        break;
                    case 'variants':
                        sigmaRow.classList.remove('hidden');
                        vaccinationGroup.classList.remove('hidden');
                        exposedCard.classList.remove('hidden');
                        break;
                }
                
                if (!this.isRunning) {
                    this.resetSimulation();
                }
            }

            initializePlot() {
                const layout = {
                    title: 'Epidemic Curve',
                    xaxis: { title: 'Days' },
                    yaxis: { title: 'Population' },
                    showlegend: true,
                    margin: { t: 40, r: 20, b: 40, l: 60 }
                };

                const traces = [
                    {
                        x: [],
                        y: [],
                        name: 'Susceptible',
                        line: { color: '#3498db' },
                        type: 'scatter'
                    },
                    {
                        x: [],
                        y: [],
                        name: 'Infected',
                        line: { color: '#e74c3c' },
                        type: 'scatter'
                    },
                    {
                        x: [],
                        y: [],
                        name: 'Recovered',
                        line: { color: '#27ae60' },
                        type: 'scatter'
                    }
                ];

                if (this.scenario === 'seir' || this.scenario === 'variants') {
                    traces.splice(1, 0, {
                        x: [],
                        y: [],
                        name: 'Exposed',
                        line: { color: '#f39c12' },
                        type: 'scatter'
                    });
                }

                Plotly.newPlot('mainChart', traces, layout, {responsive: true});
            }

            step() {
                const N = this.params.population;
                const dt = 1; // Time step of 1 day

                let dS, dE, dI, dR, dV;

                switch(this.scenario) {
                    case 'sir':
                        dS = -this.params.beta * this.state.S * this.state.I / N;
                        dI = this.params.beta * this.state.S * this.state.I / N - this.params.gamma * this.state.I;
                        dR = this.params.gamma * this.state.I;
                        
                        this.state.S += dS * dt;
                        this.state.I += dI * dt;
                        this.state.R += dR * dt;
                        break;
                        
                    case 'seir':
                    case 'variants':
                        dS = -this.params.beta * this.state.S * this.state.I / N;
                        dE = this.params.beta * this.state.S * this.state.I / N - this.params.sigma * this.state.E;
                        dI = this.params.sigma * this.state.E - this.params.gamma * this.state.I;
                        dR = this.params.gamma * this.state.I;
                        
                        this.state.S += dS * dt;
                        this.state.E += dE * dt;
                        this.state.I += dI * dt;
                        this.state.R += dR * dt;
                        break;
                        
                    case 'vaccination':
                        const vaccinationDaily = this.params.vaccinationRate * this.state.S;
                        
                        dS = -this.params.beta * this.state.S * this.state.I / N - vaccinationDaily;
                        dI = this.params.beta * this.state.S * this.state.I / N - this.params.gamma * this.state.I;
                        dR = this.params.gamma * this.state.I;
                        dV = vaccinationDaily;
                        
                        this.state.S += dS * dt;
                        this.state.I += dI * dt;
                        this.state.R += dR * dt;
                        this.state.V += dV * dt;
                        break;
                }

                // Ensure non-negative values
                Object.keys(this.state).forEach(key => {
                    this.state[key] = Math.max(0, this.state[key]);
                });

                this.currentDay++;
                this.recordData();
                this.updateDisplay();
                this.updatePlot();
            }

            recordData() {
                this.data.time.push(this.currentDay);
                this.data.susceptible.push(Math.round(this.state.S));
                this.data.exposed.push(Math.round(this.state.E));
                this.data.infected.push(Math.round(this.state.I));
                this.data.recovered.push(Math.round(this.state.R));
                this.data.vaccinated.push(Math.round(this.state.V));
            }

            updateDisplay() {
                document.getElementById('susceptibleCount').textContent = Math.round(this.state.S).toLocaleString();
                document.getElementById('infectedCount').textContent = Math.round(this.state.I).toLocaleString();
                document.getElementById('recoveredCount').textContent = Math.round(this.state.R).toLocaleString();
                document.getElementById('exposedCount').textContent = Math.round(this.state.E).toLocaleString();
                document.getElementById('currentDay').textContent = `Day: ${this.currentDay}`;
                
                const status = this.isRunning ? 'Running' : 'Paused';
                document.getElementById('simulationStatus').textContent = status;
            }

            updatePlot() {
                const update = {
                    x: [this.data.time, this.data.time, this.data.time],
                    y: [this.data.susceptible, this.data.infected, this.data.recovered]
                };

                if (this.scenario === 'seir' || this.scenario === 'variants') {
                    update.x.splice(1, 0, this.data.time);
                    update.y.splice(1, 0, this.data.exposed);
                }

                Plotly.redraw('mainChart', update);
            }

            start() {
                if (!this.isRunning) {
                    this.isRunning = true;
                    this.intervalId = setInterval(() => {
                        this.step();
                        if (this.currentDay >= this.params.timeSteps || this.state.I < 1) {
                            this.stop();
                        }
                    }, this.params.updateInterval);
                    document.getElementById('simulationStatus').textContent = 'Running';
                }
            }

            stop() {
                if (this.isRunning) {
                    this.isRunning = false;
                    if (this.intervalId) {
                        clearInterval(this.intervalId);
                        this.intervalId = null;
                    }
                    document.getElementById('simulationStatus').textContent = 'Stopped';
                }
            }

            reset() {
                this.stop();
                this.currentDay = 0;
                this.initializeParameters();
                
                // Update parameters from UI
                Object.keys(this.params).forEach(param => {
                    const input = document.getElementById(param);
                    if (input) {
                        this.params[param] = parseFloat(input.value);
                    }
                });

                this.state = {
                    S: this.params.population - this.params.initialInfected,
                    E: 0,
                    I: this.params.initialInfected,
                    R: 0,
                    V: 0
                };

                this.data = {
                    time: [],
                    susceptible: [],
                    exposed: [],
                    infected: [],
                    recovered: [],
                    vaccinated: []
                };

                this.updateDisplay();
                this.initializePlot();
                this.updateR0();
            }
        }

        // Global simulation instance
        let simulation;

        // UI Functions
        function setScenario(scenario) {
            simulation.setScenario(scenario);
        }

        function startSimulation() {
            simulation.start();
        }

        function stopSimulation() {
            simulation.stop();
        }        function resetSimulation() {
            simulation.reset();
        }

        // Distributed Simulation UI Functions
        async function saveCurrentSimulation() {
            const parameters = getCurrentParameters();
            const results = {
                time: simulation.data.time,
                susceptible: simulation.data.susceptible,
                infected: simulation.data.infected,
                recovered: simulation.data.recovered,
                exposed: simulation.data.exposed
            };
            
            const saved = await saveSimulation(parameters, simulation.scenario, results);
            if (saved) {
                updateStatusIndicator('apiStatus', 'Simulation saved âœ“', 'success');
            } else {
                updateStatusIndicator('apiStatus', 'Save failed âœ—', 'error');
            }
        }

        async function loadSimulationFromAPI() {
            if (currentSimulationId) {
                try {
                    const response = await fetch(`${API_BASE_URL}/simulations/${currentSimulationId}`);
                    if (response.ok) {
                        const data = await response.json();
                        // Apply loaded parameters to UI
                        Object.keys(data.parameters).forEach(param => {
                            const input = document.getElementById(param);
                            if (input) {
                                input.value = data.parameters[param];
                            }
                        });
                        
                        // Reset and apply loaded data
                        simulation.reset();
                        updateStatusIndicator('apiStatus', 'Simulation loaded âœ“', 'success');
                    } else {
                        throw new Error('Failed to load simulation');
                    }
                } catch (error) {
                    updateStatusIndicator('apiStatus', 'Load failed âœ—', 'error');
                }
            } else {
                updateStatusIndicator('apiStatus', 'No simulation ID âš ', 'warning');
            }
        }

        function runDistributedSim() {
            const parameters = getCurrentParameters();
            const success = runDistributedSimulation(parameters, simulation.scenario);
            
            if (success) {
                updateStatusIndicator('agentsStatus', 'Distributed running âš¡', 'info');
            } else {
                updateStatusIndicator('agentsStatus', 'Local simulation ðŸ’»', 'warning');
                // Fall back to local simulation
                simulation.start();
            }
        }

        // Update status indicator helper
        function updateStatusIndicator(elementId, text, type) {
            const element = document.getElementById(elementId);
            if (element) {
                element.textContent = text;
                element.style.background = getStatusColor(type);
                element.style.color = type === 'success' || type === 'error' ? 'white' : '#333';
            }
        }

        function getStatusColor(type) {
            switch(type) {
                case 'success': return '#27ae60';
                case 'error': return '#e74c3c';
                case 'warning': return '#f39c12';
                case 'info': return '#3498db';
                default: return '#f8f9fa';
            }
        }

        // Enhanced checkServiceHealth with UI updates
        async function checkServiceHealthWithUI() {
            const { api, agents } = await checkServiceHealth();
            
            updateStatusIndicator('apiStatus', api ? 'API Ready âœ“' : 'API Offline âœ—', api ? 'success' : 'error');
            updateStatusIndicator('agentsStatus', agents ? 'Agents Ready âœ“' : 'Agents Offline âœ—', agents ? 'success' : 'error');
            
            return { api, agents };
        }        // Check service health on load
        window.onload = async () => {
            // Initialize simulation instance first
            simulation = new SIRSimulation();
            
            // Check service health with UI updates
            const { api, agents } = await checkServiceHealthWithUI();
            
            // If services are healthy, start agent connection
            if (api && agents) {
                initializeAgentConnection();
            }
            
            // Update WebSocket status
            updateStatusIndicator('wsStatus', 'Connecting...', 'info');
        };
    </script>
</body>
</html>
