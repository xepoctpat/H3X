<!DOCTYPE html><html lang="en"><head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://code.jquery.com https://unpkg.com https://d3js.org https://threejs.org https://cdn.plot.ly https://stackpath.bootstrapcdn.com https://maps.googleapis.com https://cdn.tailwindcss.com https://ajax.googleapis.com https://kit.fontawesome.com https://cdn.datatables.net https://maxcdn.bootstrapcdn.com https://code.highcharts.com https://tako-static-assets-production.s3.amazonaws.com https://www.youtube.com https://fonts.googleapis.com https://fonts.gstatic.com https://pfst.cf2.poecdn.net https://puc.poecdn.net https://i.imgur.com https://wikimedia.org https://*.icons8.com https://*.giphy.com https://picsum.photos https://images.unsplash.com; frame-src 'self' https://www.youtube.com https://trytako.com; child-src 'self'; manifest-src 'self'; worker-src 'self'; upgrade-insecure-requests; block-all-mixed-content;">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hexperiment Labs - SIR Control Interface</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            color: #e0e0e0;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            -webkit-backdrop-filter: blur(10px); /* Safari support */
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 255, 255, 0.2);
        }

        .header h1 {
            font-size: 2.5rem;
            background: linear-gradient(45deg, #00ffff, #0066cc);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }

        .header .subtitle {
            color: #a0a0a0;
            font-size: 1.1rem;
        }

        .nav-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .tab-button {
            padding: 12px 24px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 8px;
            color: #e0e0e0;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1rem;
            border: none;
        }

        .tab-button:hover {
            background: rgba(0, 255, 255, 0.2);
            transform: translateY(-2px);
        }

        .tab-button.active {
            background: linear-gradient(45deg, #0066cc, #00ffff);
            border-color: #00ffff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.4);
        }

        .page {
            display: none;
            animation: fadeIn 0.5s ease-in;
        }

        .page.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Dashboard Styles */
        .dashboard-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .metric-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(0, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            transition: transform 0.3s ease;
        }

        .metric-card:hover {
            transform: translateY(-5px);
            border-color: rgba(0, 255, 255, 0.5);
        }

        .metric-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .metric-title {
            font-size: 1.1rem;
            color: #00ffff;
            font-weight: 600;
        }

        .metric-value {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .metric-value-passive { color: #00ff00; }
        .metric-value-active { color: #ffaa00; }
        .metric-value-anomaly { color: #00ff00; }
        .metric-value-accuracy { color: #00ffff; }

        .metric-description {
            color: #a0a0a0;
            font-size: 0.9rem;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .status-active { background: #00ff00; box-shadow: 0 0 10px #00ff00; }
        .status-warning { background: #ffaa00; box-shadow: 0 0 10px #ffaa00; }
        .status-error { background: #ff0000; box-shadow: 0 0 10px #ff0000; }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #0066cc, #00ffff);
            transition: width 0.3s ease;
            border-radius: 4px;
        }

        .progress-fill-w78 { width: 78%; }
        .progress-fill-w92 { width: 92%; }
        .progress-fill-w65 { width: 65%; }
        .progress-fill-w97 { width: 97%; }
        .progress-fill-w84 { width: 84%; }
        .progress-fill-w100 { width: 100%; }

        /* Visualization Styles */
        .visualization-container {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(0, 255, 255, 0.2);
            -webkit-backdrop-filter: blur(10px); /* Safari support */
            backdrop-filter: blur(10px);
            margin-bottom: 20px;
        }

        .simulation-display {
            height: 600px;
            background: linear-gradient(45deg, #001122 0%, #003366 50%, #002244 100%);
            border-radius: 10px;
            position: relative;
            overflow: hidden;
            border: 2px solid rgba(0, 255, 255, 0.3);
        }

        #threejs-container {
            width: 100%;
            height: 100%;
            border-radius: 8px;
        }

        .control-panel {
            display: flex;
            gap: 15px;
            margin-top: 20px;
            flex-wrap: wrap;
            align-items: center;
        }

        .control-button {
            padding: 10px 20px;
            background: rgba(0, 255, 255, 0.2);
            border: 1px solid rgba(0, 255, 255, 0.5);
            border-radius: 8px;
            color: #e0e0e0;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .control-button:hover {
            background: rgba(0, 255, 255, 0.3);
            transform: scale(1.05);
        }

        .control-button.danger {
            background: rgba(255, 0, 0, 0.2);
            border-color: rgba(255, 0, 0, 0.5);
        }

        .control-button.danger:hover {
            background: rgba(255, 0, 0, 0.3);
        }

        .simulation-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .info-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(0, 255, 255, 0.2);
        }

        .info-label {
            color: #00ffff;
            font-size: 0.9rem;
            margin-bottom: 5px;
        }

        .info-value {
            font-size: 1.2rem;
            font-weight: bold;
        }

        .people-scenario {
            margin-top: 30px;
            background: rgba(255,255,255,0.04);
            border-radius: 15px;
            padding: 24px;
            border: 1px solid rgba(0,255,255,0.15);
            display: flex;
            flex-wrap: wrap;
            gap: 24px;
            align-items: flex-start;
        }

        .person-card {
            background: rgba(0,255,255,0.08);
            border-radius: 12px;
            padding: 18px 20px;
            min-width: 180px;
            box-shadow: 0 2px 12px #00ffff22;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .person-avatar {
            width: 64px;
            height: 64px;
            border-radius: 50%;
            background: linear-gradient(135deg, #00ffff 0%, #0066cc 100%);
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.2em;
            color: #fff;
            -webkit-background-clip: padding-box;
            background-clip: padding-box;
        }

        .person-name {
            font-weight: bold;
            font-size: 1.1em;
            color: #00ffff;
        }

        .person-role {
            color: #a0a0a0;
            font-size: 0.95em;
            margin-bottom: 6px;
        }

        .person-status {
            font-size: 0.95em;
            color: #7ed957;
        }

        .scenario-description {
            flex: 1 1 320px;
            color: #e0e0e0;
            font-size: 1.1em;
            margin-left: 24px;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .dashboard-grid {
                grid-template-columns: 1fr;
            }
            
            .control-panel {
                justify-content: center;
            }
        }

        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            font-size: 1.2rem;
            color: #00ffff;
            -webkit-backdrop-filter: blur(10px); /* Safari support */
            backdrop-filter: blur(10px);
        }

        .spinner {
            border: 3px solid rgba(0, 255, 255, 0.3);
            border-top: 3px solid #00ffff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin-right: 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="public/js/sir-dashboard.js"></script>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Hexperiment Labs</h1>
            <p class="subtitle">Super Intelligent Regulator (SIR) - Control Interface</p>
        </div>

        <div class="nav-tabs">
            <button class="tab-button active" onclick="switchTab('dashboard')">Constant Dashboard</button>
            <button class="tab-button" onclick="switchTab('visualization')">Temporary Visualization</button>
        </div>

        <!-- Dashboard Page -->
        <div class="page active" id="dashboard">
            <div class="dashboard-grid">
                <div class="metric-card">
                    <div class="metric-header">
                        <span class="metric-title">System Status</span>
                        <div class="status-indicator status-active"></div>
                    </div>
                    <div class="metric-value metric-value-passive">PASSIVE MODE</div>
                    <div class="metric-description">SIR operating in observation phase</div>
                    <div class="progress-bar">
                        <div class="progress-fill progress-fill-w78"></div>
                    </div>
                </div>

                <div class="metric-card">
                    <div class="metric-header">
                        <span class="metric-title">Simulation Cycles</span>
                        <div class="status-indicator status-active"></div>
                    </div>
                    <div class="metric-value">2,847</div>
                    <div class="metric-description">Real-world environment simulations completed</div>
                    <div class="progress-bar">
                        <div class="progress-fill progress-fill-w92"></div>
                    </div>
                </div>

                <div class="metric-card">
                    <div class="metric-header">
                        <span class="metric-title">Data Points Collected</span>
                        <div class="status-indicator status-active"></div>
                    </div>
                    <div class="metric-value">1.2M</div>
                    <div class="metric-description">Behavioral patterns and environmental factors</div>
                    <div class="progress-bar">
                        <div class="progress-fill progress-fill-w65"></div>
                    </div>
                </div>

                <div class="metric-card">
                    <div class="metric-header">
                        <span class="metric-title">Learning Accuracy</span>
                        <div class="status-indicator status-active"></div>
                    </div>
                    <div class="metric-value metric-value-accuracy">97.3%</div>
                    <div class="metric-description">Pattern recognition and prediction accuracy</div>
                    <div class="progress-bar">
                        <div class="progress-fill progress-fill-w97"></div>
                    </div>
                </div>

                <div class="metric-card">
                    <div class="metric-header">
                        <span class="metric-title">Environmental Factors</span>
                        <div class="status-indicator status-active"></div>
                    </div>
                    <div class="metric-value">156</div>
                    <div class="metric-description">Unique environmental conditions analyzed</div>
                    <div class="progress-bar">
                        <div class="progress-fill progress-fill-w84"></div>
                    </div>
                </div>

                <div class="metric-card">
                    <div class="metric-header">
                        <span class="metric-title">Anomaly Detection</span>
                        <div class="status-indicator status-active"></div>
                    </div>
                    <div class="metric-value metric-value-anomaly">0</div>
                    <div class="metric-description">No anomalies detected in current cycle</div>
                    <div class="progress-bar">
                        <div class="progress-fill progress-fill-w100"></div>
                    </div>
                </div>
            </div>

            <div class="people-scenario">
                <div class="person-card">
                    <div class="person-avatar">üë©‚Äçüî¨</div>
                    <div class="person-name">Dr. Mira Novak</div>
                    <div class="person-role">Biologist</div>
                    <div class="person-status">Active in Lab</div>
                </div>
                <div class="person-card">
                    <div class="person-avatar">üßë‚ÄçüöÄ</div>
                    <div class="person-name">Alex Kim</div>
                    <div class="person-role">Field Researcher</div>
                    <div class="person-status">Exploring Wetlands</div>
                </div>
                <div class="person-card">
                    <div class="person-avatar">üë®‚Äçüíª</div>
                    <div class="person-name">Samir Patel</div>
                    <div class="person-role">Data Scientist</div>
                    <div class="person-status">Analyzing Data</div>
                </div>
                <div class="scenario-description">
                    <strong>Scenario:</strong> <br>
                    <span>In this environment, a multidisciplinary team collaborates to monitor and enhance the health of a wetland ecosystem. Real-time data from sensors and field observations are visualized, with each person contributing unique expertise. The dashboard reflects not only environmental metrics but also the status and activity of each team member, providing a holistic, life-centric view of the scenario.</span>
                </div>
            </div>
        </div>

        <!-- Visualization Page -->
        <div class="page" id="visualization">
            <div class="visualization-container">
                <div class="metric-header">
                    <span class="metric-title">Advanced 3D Neural Network Simulation</span>
                    <div class="status-indicator status-active"></div>
                </div>
                <div class="simulation-display">
                    <div id="threejs-container">
                        <div class="loading">
                            <div class="spinner"></div>
                            Initializing Advanced 3D Environment...
                        </div>
                    </div>
                </div>
                
                <div class="control-panel">
                    <button class="control-button" onclick="toggleSimulation()">Pause/Resume</button>
                    <button class="control-button" onclick="resetView()">Reset View</button>
                    <button class="control-button" onclick="toggleWireframe()">Toggle Wireframe</button>
                    <button class="control-button" onclick="toggleParticles()">Toggle Particles</button>
                    <button class="control-button" onclick="changeEnvironment()">Change Environment</button>
                    <button class="control-button danger" onclick="validateSimulation()">Validate &amp; Proceed</button>
                </div>
            </div>

            <div class="simulation-info">
                <div class="info-item">
                    <div class="info-label">Neural Nodes</div>
                    <div class="info-value" id="active-entities">247</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Active Connections</div>
                    <div class="info-value" id="interaction-events">1,834</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Environment Type</div>
                    <div class="info-value" id="environment-type">Neural Matrix</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Simulation Time</div>
                    <div class="info-value" id="sim-time">04:27:33</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Processing Power</div>
                    <div class="info-value" id="processing-power">94.7%</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Data Throughput</div>
                    <div class="info-value" id="data-throughput">2.4 GB/s</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Tab switching functionality
        function switchTab(tabName) {
            document.querySelectorAll('.page').forEach(page => {
                page.classList.remove('active');
            });
            
            document.querySelectorAll('.tab-button').forEach(button => {
                button.classList.remove('active');
            });
            
            document.getElementById(tabName).classList.add('active');
            event.target.classList.add('active');
            
            if (tabName === 'visualization' && !window.threeJSInitialized) {
                setTimeout(init3DScene, 100);
            }
        }

        // Enhanced Three.js scene variables
        let scene, camera, renderer, composer, entities = [], connections = [], 
            particleSystem, neuralNetwork = [], isSimulationRunning = true, 
            wireframeMode = false, particlesEnabled = true, currentEnvironment = 0;
        
        window.threeJSInitialized = false;

        // Placeholder for geomaap data (replace with real data loading logic)
        let geomaapData = Array.from({length: 100}, (_, i) => ({ id: i, value: Math.random() })); // Example: 100 data points

        function init3DScene() {
            const container = document.getElementById('threejs-container');
            container.innerHTML = '';

            // Scene setup with enhanced background
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000511);
            scene.fog = new THREE.FogExp2(0x000511, 0.002);

            // Enhanced camera setup
            camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 2000);
            camera.position.set(0, 50, 100);
            camera.lookAt(0, 0, 0);

            // Enhanced renderer with better quality
            renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 0.8;
            container.appendChild(renderer.domElement);

            // Advanced lighting system
            setupAdvancedLighting();

            // Create neural network visualization
            createNeuralNetwork();
            
            // Create particle systems
            createParticleSystem();
            
            // Create enhanced environment
            createAdvancedEnvironment();
            
            // Create connection lines
            createConnections();

            // Enhanced mouse controls
            setupMouseControls(container);

            // Handle window resize
            window.addEventListener('resize', onWindowResize, false);

            window.threeJSInitialized = true;
            animate();
        }

        function setupAdvancedLighting() {
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0x1a237e, 0.4);
            scene.add(ambientLight);

            // Main directional light
            const mainLight = new THREE.DirectionalLight(0x00ffff, 1.2);
            mainLight.position.set(50, 100, 50);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.width = 4096;
            mainLight.shadow.mapSize.height = 4096;
            mainLight.shadow.camera.near = 0.5;
            mainLight.shadow.camera.far = 500;
            mainLight.shadow.camera.left = -100;
            mainLight.shadow.camera.right = 100;
            mainLight.shadow.camera.top = 100;
            mainLight.shadow.camera.bottom = -100;
            scene.add(mainLight);

            // Accent lights
            const accentLight1 = new THREE.PointLight(0xff6b35, 0.8, 200);
            accentLight1.position.set(-50, 30, -50);
            scene.add(accentLight1);

            const accentLight2 = new THREE.PointLight(0x4fc3f7, 0.6, 150);
            accentLight2.position.set(50, 20, 50);
            scene.add(accentLight2);

            // Rim light
            const rimLight = new THREE.DirectionalLight(0x81c784, 0.5);
            rimLight.position.set(-30, 10, -30);
            scene.add(rimLight);
        }

        function createNeuralNetwork() {
            neuralNetwork = [];
            entities = [];

            // Create layers of neural nodes
            const layers = [
                { nodeCount: 8, radius: 40, y: 0, color: 0x00ffff },
                { nodeCount: 12, radius: 60, y: 20, color: 0xff6b35 },
                { nodeCount: 16, radius: 80, y: 40, color: 0x4fc3f7 },
                { nodeCount: 12, radius: 60, y: 60, color: 0x81c784 },
                { nodeCount: 8, radius: 40, y: 80, color: 0xe1bee7 }
            ];

            layers.forEach((layer, layerIndex) => {
                const layerNodes = [];
                for (let i = 0; i < layer.nodeCount; i++) {
                    const angle = (i / layer.nodeCount) * Math.PI * 2;
                    
                    // Enhanced node geometry
                    const geometry = new THREE.IcosahedronGeometry(1.5, 1);
                    const material = new THREE.MeshPhongMaterial({ 
                        color: layer.color,
                        transparent: true,
                        opacity: 0.8,
                        emissive: new THREE.Color(layer.color).multiplyScalar(0.2),
                        shininess: 100
                    });
                    
                    const node = new THREE.Mesh(geometry, material);
                    node.position.set(
                        Math.cos(angle) * layer.radius,
                        layer.y,
                        Math.sin(angle) * layer.radius
                    );
                    
                    node.castShadow = true;
                    node.receiveShadow = true;
                    
                    // Add glow effect
                    const glowGeometry = new THREE.IcosahedronGeometry(2.2, 1);
                    const glowMaterial = new THREE.MeshBasicMaterial({
                        color: layer.color,
                        transparent: true,
                        opacity: 0.1,
                        side: THREE.BackSide
                    });
                    const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                    node.add(glow);
                    
                    node.userData = {
                        originalPosition: node.position.clone(),
                        pulseOffset: Math.random() * Math.PI * 2,
                        rotationSpeed: (Math.random() + 0.5) * 0.01,
                        layer: layerIndex,
                        nodeIndex: i
                    };
                    
                    scene.add(node);
                    entities.push(node);
                    layerNodes.push(node);
                }
                neuralNetwork.push(layerNodes);
            });

            // Create floating data entities based on geomaapData length
            const illusionCount = geomaapData.length;
            for (let i = 0; i < illusionCount; i++) {
                const geometry = new THREE.TetrahedronGeometry(0.8, 0);
                const material = new THREE.MeshPhongMaterial({ 
                    color: new THREE.Color().setHSL(Math.random(), 0.8, 0.6),
                    transparent: true,
                    opacity: 0.7,
                    emissive: new THREE.Color().setHSL(Math.random(), 0.5, 0.1)
                });
                const entity = new THREE.Mesh(geometry, material);
                entity.position.set(
                    (Math.random() - 0.5) * 200,
                    Math.random() * 100 + 10,
                    (Math.random() - 0.5) * 200
                );
                entity.castShadow = true;
                entity.userData = {
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.5,
                        (Math.random() - 0.5) * 0.2,
                        (Math.random() - 0.5) * 0.5
                    ),
                    rotationVelocity: new THREE.Vector3(
                        Math.random() * 0.02,
                        Math.random() * 0.02,
                        Math.random() * 0.02
                    ),
                    geomaap: geomaapData[i] // Attach data for future use
                };
                scene.add(entity);
                entities.push(entity);
            }

            // Assign personas to neural nodes (SIR agent modeling)
            assignPersonasToEntities(entities);
        }

        // Function to update illusions when geomaap data changes
        function updateIllusionsFromGeomaap(newData) {
            geomaapData = newData;
            // Remove old illusions
            entities.forEach(e => { if (e.geometry && e.geometry.type === 'TetrahedronGeometry') scene.remove(e); });
            // Add new illusions
            for (let i = 0; i < geomaapData.length; i++) {
                const geometry = new THREE.TetrahedronGeometry(0.8, 0);
                const material = new THREE.MeshPhongMaterial({ 
                    color: new THREE.Color().setHSL(Math.random(), 0.8, 0.6),
                    transparent: true,
                    opacity: 0.7,
                    emissive: new THREE.Color().setHSL(Math.random(), 0.5, 0.1)
                });
                const entity = new THREE.Mesh(geometry, material);
                entity.position.set(
                    (Math.random() - 0.5) * 200,
                    Math.random() * 100 + 10,
                    (Math.random() - 0.5) * 200
                );
                entity.castShadow = true;
                entity.userData = {
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.5,
                        (Math.random() - 0.5) * 0.2,
                        (Math.random() - 0.5) * 0.5
                    ),
                    rotationVelocity: new THREE.Vector3(
                        Math.random() * 0.02,
                        Math.random() * 0.02,
                        Math.random() * 0.02
                    ),
                    geomaap: geomaapData[i]
                };
                scene.add(entity);
                entities.push(entity);
            }
        }

        function createConnections() {
            connections = [];
            
            // Create connections between neural network layers
            for (let layerIndex = 0; layerIndex < neuralNetwork.length - 1; layerIndex++) {
                const currentLayer = neuralNetwork[layerIndex];
                const nextLayer = neuralNetwork[layerIndex + 1];
                
                currentLayer.forEach(sourceNode => {
                    nextLayer.forEach(targetNode => {
                        if (Math.random() > 0.7) { // Random connections
                            const points = [sourceNode.position, targetNode.position];
                            const geometry = new THREE.BufferGeometry().setFromPoints(points);
                            const material = new THREE.LineBasicMaterial({
                                color: 0x00ffff,
                                transparent: true,
                                opacity: 0.3
                            });
                            const line = new THREE.Line(geometry, material);
                            line.userData = {
                                sourceNode: sourceNode,
                                targetNode: targetNode,
                                pulseOffset: Math.random() * Math.PI * 2
                            };
                            scene.add(line);
                            connections.push(line);
                        }
                    });
                });
            }
        }

        function createParticleSystem() {
            const particleCount = 2000;
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);

            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                
                // Position
                positions[i3] = (Math.random() - 0.5) * 400;
                positions[i3 + 1] = (Math.random() - 0.5) * 200;
                positions[i3 + 2] = (Math.random() - 0.5) * 400;
                
                // Color
                const color = new THREE.Color().setHSL(Math.random() * 0.3 + 0.5, 0.8, 0.5);
                colors[i3] = color.r;
                colors[i3 + 1] = color.g;
                colors[i3 + 2] = color.b;
                
                // Size
                sizes[i] = Math.random() * 2 + 1;
            }

            const particleGeometry = new THREE.BufferGeometry();
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            particleGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const particleMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 }
                },
                vertexShader: `
                    attribute float size;
                    attribute vec3 color;
                    varying vec3 vColor;
                    uniform float time;
                    
                    void main() {
                        vColor = color;
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        gl_PointSize = size * (300.0 / -mvPosition.z) * (1.0 + 0.5 * sin(time + position.x * 0.01));
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;
                    
                    void main() {
                        float distanceToCenter = distance(gl_PointCoord, vec2(0.5));
                        if (distanceToCenter > 0.5) discard;
                        
                        float alpha = 1.0 - smoothstep(0.0, 0.5, distanceToCenter);
                        gl_FragColor = vec4(vColor, alpha * 0.8);
                    }
                `,
                transparent: true,
                vertexColors: true,
                blending: THREE.AdditiveBlending
            });

            particleSystem = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particleSystem);
        }

        function createAdvancedEnvironment() {
            // Enhanced ground with hexagonal pattern
            const groundGeometry = new THREE.PlaneGeometry(300, 300, 32, 32);
            const groundMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x0a1628, 
                transparent: true, 
                opacity: 0.8,
                wireframe: false
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Hexagonal grid overlay
            const hexGrid = new THREE.GridHelper(300, 60, 0x00ffff, 0x004466);
            hexGrid.material.opacity = 0.2;
            hexGrid.material.transparent = true;
            scene.add(hexGrid);

            // Create abstract architectural elements
            for (let i = 0; i < 20; i++) {
                const height = Math.random() * 15 + 5;
                const geometry = new THREE.CylinderGeometry(
                    Math.random() * 1 + 0.5,
                    Math.random() * 2 + 1,
                    height,
                    8
                );
                const material = new THREE.MeshPhongMaterial({ 
                    color: new THREE.Color().setHSL(0.55, 0.4, 0.3),
                    transparent: true,
                    opacity: 0.7,
                    emissive: new THREE.Color().setHSL(0.55, 0.2, 0.05)
                });
                const structure = new THREE.Mesh(geometry, material);
                
                structure.position.set(
                    (Math.random() - 0.5) * 200,
                    height / 2,
                    (Math.random() - 0.5) * 200
                );
                
                structure.castShadow = true;
                structure.receiveShadow = true;
                scene.add(structure);
            }

            // Add floating rings
            for (let i = 0; i < 8; i++) {
                const ringGeometry = new THREE.TorusGeometry(10, 0.5, 8, 16);
                const ringMaterial = new THREE.MeshPhongMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.6,
                    emissive: 0x002244
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                
                ring.position.set(
                    (Math.random() - 0.5) * 150,
                    Math.random() * 60 + 20,
                    (Math.random() - 0.5) * 150
                );
                ring.rotation.set(
                    Math.random() * Math.PI,
                    Math.random() * Math.PI,
                    Math.random() * Math.PI
                );
                
                ring.userData = {
                    rotationSpeed: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.02,
                        (Math.random() - 0.5) * 0.02,
                        (Math.random() - 0.5) * 0.02
                    )
                };
                
                scene.add(ring);
                entities.push(ring);
            }
        }

        // Enhanced MoE-based Ego Drive Persona Generator
        function PersonaGenerator(drives) {
            this.drives = drives || [
                { name: 'curiosity', expert: 'Explorer', weight: 0 },
                { name: 'survival', expert: 'Survivor', weight: 0 },
                { name: 'social', expert: 'Collaborator', weight: 0 },
                { name: 'achievement', expert: 'Achiever', weight: 0 },
                { name: 'order', expert: 'Organizer', weight: 0 },
                { name: 'chaos', expert: 'Disruptor', weight: 0 }
            ];
        }

        PersonaGenerator.prototype.generate = function() {
            // Assign random weights (sum to 1)
            let weights = [];
            let total = 0;
            for (let i = 0; i < this.drives.length; i++) {
                let w = Math.random();
                weights.push(w);
                total += w;
            }
            // Normalize
            weights = weights.map(w => w / total);
            // Assign to persona
            let persona = { egoProfile: [] };
            for (let i = 0; i < this.drives.length; i++) {
                persona.egoProfile.push({
                    name: this.drives[i].name,
                    expert: this.drives[i].expert,
                    weight: weights[i]
                });
            }
            // Optionally, add a dominant drive
            persona.dominantDrive = persona.egoProfile.reduce((a, b) => a.weight > b.weight ? a : b);
            return persona;
        };

        // Attach persona to each neural node entity
        function assignPersonasToEntities(entities) {
            const generator = new PersonaGenerator();
            entities.forEach(entity => {
                if (entity.userData && entity.userData.originalPosition) {
                    entity.userData.persona = generator.generate();
                }
            });
        }

        // In createNeuralNetwork, after creating all entities:
        // assignPersonasToEntities(entities);

        function setupMouseControls(container) {
            let mouseX = 0, mouseY = 0;
            let targetX = 0, targetY = 0;
            
            container.addEventListener('mousemove', (event) => {
                mouseX = (event.clientX / container.clientWidth) * 2 - 1;
                mouseY = -(event.clientY / container.clientHeight) * 2 + 1;
                
                targetX = mouseX * 0.05;
                targetY = mouseY * 0.05;
            });

            // Smooth camera movement based on mouse
            function updateCameraPosition() {
                camera.position.x += (targetX * 10 - camera.position.x) * 0.02;
                camera.position.y += (targetY * 10 + 50 - camera.position.y) * 0.02;
                requestAnimationFrame(updateCameraPosition);
            }
            updateCameraPosition();

            // Add click event to inspect persona
            container.addEventListener('click', (event) => {
                // Raycast to find intersected neural node
                const rect = container.getBoundingClientRect();
                const mouse = new THREE.Vector2(
                    ((event.clientX - rect.left) / container.clientWidth) * 2 - 1,
                    -((event.clientY - rect.top) / container.clientHeight) * 2 + 1
                );
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(entities);
                if (intersects.length > 0) {
                    const obj = intersects[0].object;
                    if (obj.userData && obj.userData.persona) {
                        console.log('SIR Persona:', obj.userData.persona);
                        alert('Dominant Drive: ' + obj.userData.persona.dominantDrive.name + '\n' +
                            obj.userData.persona.egoProfile.map(d => `${d.expert}: ${(d.weight*100).toFixed(1)}%`).join('\n'));
                    }
                }
            });
        }

        function animate() {
            requestAnimationFrame(animate);

            if (isSimulationRunning) {
                const time = Date.now() * 0.001;

                // Animate neural network nodes
                entities.forEach((entity, index) => {
                    if (entity.userData.originalPosition) {
                        // Neural nodes
                        const pulse = Math.sin(time * 2 + entity.userData.pulseOffset) * 0.5;
                        entity.scale.setScalar(1 + pulse * 0.3);
                        entity.rotation.x += entity.userData.rotationSpeed;
                        entity.rotation.y += entity.userData.rotationSpeed * 1.5;
                        
                        // Subtle position oscillation
                        entity.position.y = entity.userData.originalPosition.y + Math.sin(time + index) * 2;
                    } else if (entity.userData.velocity) {
                        // Floating entities
                        entity.position.add(entity.userData.velocity);
                        entity.rotation.x += entity.userData.rotationVelocity.x;
                        entity.rotation.y += entity.userData.rotationVelocity.y;
                        entity.rotation.z += entity.userData.rotationVelocity.z;
                        
                        // Boundary checking
                        if (Math.abs(entity.position.x) > 100) entity.userData.velocity.x *= -1;
                        if (Math.abs(entity.position.z) > 100) entity.userData.velocity.z *= -1;
                        if (entity.position.y > 100 || entity.position.y < 5) entity.userData.velocity.y *= -1;
                    } else if (entity.userData.rotationSpeed) {
                        // Floating rings
                        entity.rotation.x += entity.userData.rotationSpeed.x;
                        entity.rotation.y += entity.userData.rotationSpeed.y;
                        entity.rotation.z += entity.userData.rotationSpeed.z;
                    }
                });

                // Animate connections
                connections.forEach(connection => {
                    const opacity = 0.3 + Math.sin(time * 3 + connection.userData.pulseOffset) * 0.2;
                    connection.material.opacity = Math.max(0.1, opacity);
                });

                // Animate particles
                if (particleSystem && particlesEnabled) {
                    particleSystem.material.uniforms.time.value = time;
                    particleSystem.rotation.y += 0.001;
                    
                    const positions = particleSystem.geometry.attributes.position.array;
                    for (let i = 0; i < positions.length; i += 3) {
                        positions[i + 1] += Math.sin(time + positions[i] * 0.01) * 0.02;
                    }
                    particleSystem.geometry.attributes.position.needsUpdate = true;
                }

                // Smooth camera orbit
                const radius = 120;
                camera.position.x = Math.cos(time * 0.1) * radius;
                camera.position.z = Math.sin(time * 0.1) * radius;
                camera.lookAt(0, 40, 0);
            }

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            const container = document.getElementById('threejs-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        // Enhanced control functions
        function toggleSimulation() {
            isSimulationRunning = !isSimulationRunning;
        }

        function resetView() {
            camera.position.set(0, 50, 100);
            camera.lookAt(0, 40, 0);
        }

        function toggleWireframe() {
            wireframeMode = !wireframeMode;
            entities.forEach(entity => {
                if (entity.material && entity.material.wireframe !== undefined) {
                    entity.material.wireframe = wireframeMode;
                }
            });
        }

        function toggleParticles() {
            particlesEnabled = !particlesEnabled;
            if (particleSystem) {
                particleSystem.visible = particlesEnabled;
            }
        }

        function changeEnvironment() {
            currentEnvironment = (currentEnvironment + 1) % 3;
            const environmentTypes = ['Neural Matrix', 'Quantum Field', 'Data Streams'];
            document.getElementById('environment-type').textContent = environmentTypes[currentEnvironment];
            
            // Change scene colors based on environment
            const colorSchemes = [
                { bg: 0x000511, fog: 0x000511 }, // Neural Matrix
                { bg: 0x110505, fog: 0x110505 }, // Quantum Field  
                { bg: 0x051105, fog: 0x051105 }  // Data Streams
            ];
            
            scene.background = new THREE.Color(colorSchemes[currentEnvironment].bg);
            scene.fog.color = new THREE.Color(colorSchemes[currentEnvironment].fog);
        }

        function validateSimulation() {
            if (confirm('Validate simulation and proceed to Active Mode? This will disable the detailed visualization.')) {
                alert('Advanced simulation validated successfully! Neural patterns confirmed. Transitioning to Active Mode...');
                switchTab('dashboard');
                // Update dashboard to show active mode
                document.querySelector('.metric-value[style*="color: #00ff00"]').textContent = 'ACTIVE MODE';
                document.querySelector('.metric-value[style*="color: #00ff00"]').style.color = '#ffaa00';
                document.querySelectorAll('.metric-description')[0].textContent = 'SIR generating tailored AI assistants';
            }
        }

        // Enhanced dashboard metrics updates
        setInterval(() => {
            const cycles = document.getElementById('simulation-cycles');
            const dataPoints = document.getElementById('data-points');
            const envFactors = document.getElementById('env-factors');
            const activeEntities = document.getElementById('active-entities');
            const interactionEvents = document.getElementById('interaction-events');
            const simTime = document.getElementById('sim-time');
            const processingPower = document.getElementById('processing-power');
            const dataThroughput = document.getElementById('data-throughput');

            if (cycles) cycles.textContent = (parseInt(cycles.textContent.replace(',', '')) + Math.floor(Math.random() * 3)).toLocaleString();
            if (dataPoints) {
                const current = parseFloat(dataPoints.textContent);
                dataPoints.textContent = (current + Math.random() * 0.1).toFixed(1) + 'M';
            }
            if (envFactors) envFactors.textContent = parseInt(envFactors.textContent) + Math.floor(Math.random() * 2);
            if (activeEntities) activeEntities.textContent = 247 + Math.floor(Math.random() * 20 - 10);
            if (interactionEvents) interactionEvents.textContent = parseInt(interactionEvents.textContent.replace(',', '')) + Math.floor(Math.random() * 50);
            if (processingPower) processingPower.textContent = (94 + Math.random() * 5).toFixed(1) + '%';
            if (dataThroughput) dataThroughput.textContent = (2.4 + Math.random() * 0.8).toFixed(1) + ' GB/s';
            
            // Update simulation timer
            if (simTime) {
                const [hours, minutes, seconds] = simTime.textContent.split(':').map(Number);
                const totalSeconds = hours * 3600 + minutes * 60 + seconds + 1;
                const newHours = Math.floor(totalSeconds / 3600);
                const newMinutes = Math.floor((totalSeconds % 3600) / 60);
                const newSeconds = totalSeconds % 60;
                simTime.textContent = `${newHours.toString().padStart(2, '0')}:${newMinutes.toString().padStart(2, '0')}:${newSeconds.toString().padStart(2, '0')}`;
            }
        }, 2000);

        // Ensure all hyperlinks open in a new tab and are accessible
        // This script will run after DOM is loaded
        window.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('a[href]').forEach(link => {
                // Only update if not already set
                if (!link.hasAttribute('target')) {
                    link.setAttribute('target', '_blank');
                }
                if (!link.hasAttribute('rel')) {
                    link.setAttribute('rel', 'noopener noreferrer');
                }
            });
        });
    </script>


</body></html>